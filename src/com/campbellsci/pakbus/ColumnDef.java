/* ColumnDef.java

   Copyright (C) 2006, 2009 Campbell Scientific, Inc.

   Written by: Jon Trauntvein
   Date Begun: Tuesday 10 October 2006
   Last Change: Wednesday 18 February 2009
   Last Commit: $Date: 2015/02/07 01:20:55 $
   Last Changed by: $Author: jdk85 $

*/

package com.campbellsci.pakbus;


import java.util.*;


/**
 * Defines a column definition as defined in the BMP5 table definitions.
 */
public class ColumnDef
{
   /**
    * Specifies the original order of this column in the table definitions
    */
   public int column_no;


   /**
    * Specifies the name of the column (note that this does not include any
    * dimensional information).
    */
   public String name;


   /**
    * Set to true if this column is read-only (cannot be changed using the set
    * value transaction).
    */
   public boolean read_only;


   /**
    * Specifies the type of the data for this column
    */
   public byte data_type;


   /**
    * Specifies the processing string for this column.  This string is
    * generated by the datalogger program and is dependent upon the output
    * processing instruction that was used.
    */
   public String processing;


   /**
    * Specifies the units of the data in this column.  This is a user-defined
    * string that is specified in the datalogger program.
    */
   public String units;


   /**
    * Specifies a user-specified description for this column.
    */
   public String description;


   /**
    * Specifies the beginning offset for this piece.
    */
   public int begin_index;


   /**
    * Specifies the total number of elements in this piece.
    */
   public int piece_size;
   
   
   /**
    * Holds information about the array dimensions
    */
   public ArrayDimensions dims;

   
   /**
    * This constructor is used to build up a table definition from scratch
    */
   protected ColumnDef(String name_, byte field_type_)
   {
      name = name_;
      column_no = 0;
      data_type = field_type_;
      dims = new ArrayDimensions();
      processing = new String();
      units = new String();
      description = new String();
   } // constructor
   
   
   /**
    * This constructor should generally be called only by the table definition
    * constructor. 
    *
    * @param column_no_  Specifies the value for the column number.
    * @param field_type_  Specifies the data type
    * @param message     Specifies the message from which the rest of the field
    * members will be initialised.
    */
   protected ColumnDef(
      int column_no_,
      byte field_type_,
      Packet message) throws Exception
   {
      String alias = new String();
      int dim;
      
      column_no = column_no_;
      data_type = (byte)(field_type_ & 0x7f);
      read_only = (field_type_ & 0x80) != 0;
      name = message.read_string();
      alias = message.read_string();
      while(alias.length() > 0)
         alias = message.read_string();
      processing = message.read_string();
      units = message.read_string();
      description = message.read_string();
      begin_index = message.read_int4();
      piece_size = message.read_int4();
      dims = new ArrayDimensions();
      dim = message.read_int4();
      while(dim != 0)
      {
         dims.add_dimension(dim);
         dim = message.read_int4();
      }
   } // constructor
   
   
   /**
    * @return the number of values associated with this column.
    * Note that strings are counted as scalar values and not arrays
    * of char.
    */
   public int get_values_count()
   {
      int rtn = piece_size;
      if(data_type == type_ascii)
         rtn /= dims.back();
      return rtn;
   } // get_values_count
   
   
   /**
    * @return the number of bytes needed to store values associated
    * with this column piece.
    */
   public int get_values_size()
   { return piece_size * data_type_size(data_type); }
   
   
   /**
    * Creates the formatted name for a variable in this column.  The name 
    * will include the array index, if applicable. 
    */
   public String format_name(int offset)
   {
      StringBuilder rtn = new StringBuilder();
      rtn.append(name);
      if(!dims.for_scalar(data_type == type_ascii))
      {
         List<Integer> index = dims.to_index(offset, data_type == type_ascii);
         boolean add_comma = false;
         rtn.append('(');
         for(int i = 0; i < index.size(); ++i)
         {
            if(add_comma)
               rtn.append(',');
            else
               add_comma = true;
            rtn.append(i);
         }
         rtn.append(')');
      }
      return rtn.toString();
   } // format_name


   /**
    * Generates a linear index for the specified array address
    *
    * @param array_address the array address
    * @return linear_index
    */
   public int to_linear_index(List<Integer> array_address)
   { return dims.to_offset(array_address,data_type == type_ascii); }
   

   /**
    * Returns the size of a single value for the specified data type. 
    * Note that type_ascii will NOT be given special consideration here
    */
   public static final int data_type_size(byte data_type)
   {
      int rtn = 0;
      switch(data_type)
      {
      case type_int1:
      case type_uint1:
      case type_bool8:
      case type_bool:
      case type_ascii:
         rtn = 1;
         break;
         
      case type_uint2:
      case type_int2:
      case type_bool2:
      case type_fp2:
      case type_int2_lsf:
      case type_uint2_lsf:
         rtn = 2;
         break;
         
      case type_uint4:
      case type_int4:
      case type_fp4:
      case type_ieee4:
      case type_ieee4_lsf:
      case type_bool4: 
      case type_sec:
      case type_int4_lsf:
      case type_uint4_lsf:
         rtn = 4;
         break;
         
      case type_usec:
         rtn = 6;
         break;
         
      case type_ieee8:
      case type_nsec:
      case type_ieee8_lsf:
      case type_nsec_lsf:
         rtn = 8;
      }
      return rtn;
   } // data_type_size
   
   
   // the following static values define possible values for the data_type field.
   static public final byte type_uint1 = 1;
   static public final byte type_uint2 = 2;
   static public final byte type_uint4 = 3;
   static public final byte type_int1 = 4;
   static public final byte type_int2 = 5;
   static public final byte type_int4 = 6;
   static public final byte type_fp2 = 7;
   static public final byte type_fp4 = 8;
   static public final byte type_ieee4 = 9;
   static public final byte type_ieee8 = 18;
   static public final byte type_bool8 = 17;
   static public final byte type_bool = 10;
   static public final byte type_bool2 = 27;
   static public final byte type_bool4 = 28;
   static public final byte type_sec = 12;
   static public final byte type_usec = 13;
   static public final byte type_nsec = 14;
   static public final byte type_ascii = 11;
   static public final byte type_int2_lsf = 19;
   static public final byte type_uint2_lsf = 21;
   static public final byte type_int4_lsf = 20;
   static public final byte type_uint4_lsf = 22;
   static public final byte type_ieee4_lsf = 24;
   static public final byte type_ieee8_lsf = 25;
   static public final byte type_nsec_lsf = 23;
   
}


